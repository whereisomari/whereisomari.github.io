<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Where is Omari?</title>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        /* Index-specific styles */
        .container {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            text-align: center;
        }

        .status-main, .status-details {
            text-align: center;
            width: 100%;
        }
        
        /* Stylized "Omari is probably" */
        .status-prefix {
            font-size: clamp(2rem, 6vw, 4rem);
            font-weight: 300;
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeInUp 1s ease-out 0.3s forwards, gradientCycle 5s linear infinite;
            background: linear-gradient(to right, 
                hsl(300, 80%, 70%), 
                hsl(270, 80%, 61%), 
                hsl(235, 85%, 55%), 
                hsl(300, 80%, 70%));
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
        }
        
        .status-prefix::after {
            display: none;
        }
        
        .probably {
            font-style: italic;
            text-decoration: underline;
            text-decoration-color: transparent;
            background: linear-gradient(to right, 
                hsl(300, 80%, 70%), 
                hsl(270, 80%, 61%), 
                hsl(235, 85%, 55%)) no-repeat bottom;
            background-size: 100% 2px;
            padding-bottom: 2px;
        }		
        
        .desktop-text {
            display: inline;
        }

        .mobile-text {
            display: none;
        }		
        
        /* Main status display */
        .status-main {
            font-size: clamp(2.5rem, 8vw, 6rem);
            font-weight: 800;
            line-height: 1.1;
            margin-bottom: 2rem;
            opacity: 1;
            color: #ffffff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }
        
        /* Status details */
        .status-details {
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 400;
            color: #aaa;
            opacity: 1;
        }
        
        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 1.2rem;
            color: #666;
        }
        
        .loading-dot {
            width: 8px;
            height: 8px;
            background: #666;
            border-radius: 50%;
            animation: loadingDots 1.5s ease-in-out infinite;
        }
        
        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes loadingDots {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1.2); opacity: 1; }
        }
        
        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                min-height: 80vh;
                justify-content: flex-start;
                padding-top: 15vh;
            }

            .status-prefix {
                font-size: clamp(2.8rem, 12vw, 5.5rem);
                line-height: 0.95;
                margin-bottom: 1.5rem;
            }
            
            .desktop-text {
                display: none;
            }
            
            .mobile-text {
                display: inline;
            }
        }
    </style>
</head>
<body>
    <!-- Enhanced particle background -->
    <div class="particles" id="particles"></div>
    
    <!-- Particle mask to hide stuck particles at top -->
    <div class="particle-mask"></div>
    
    <!-- Text overlay to hide content during loading -->
    <div class="text-overlay" id="textOverlay"></div>
    
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="simple-loader"></div>
    </div>

    <!-- View Calendar nav button -->
    <a href="calendar.html" class="nav-link" id="calendarNavButton" style="display: none;">View Calendar</a>
    
    <!-- Sign out link -->
    <button id="signOutButton" class="sign-out-link" onclick="signOut()" style="display: none;">Sign Out</button>	
    
    <!-- Login Screen -->
    <div class="login-splash-screen" id="loginSplashScreen" style="display: none;">
        <div class="login-content">
            <div id="loginForm">
                <input type="password" id="passwordInput" class="login-input" placeholder="Password">
                <button id="loginButton" class="login-button" onclick="signIn()">Sign In</button>
                <div id="loginError" class="login-error"></div>
            </div>
        </div>
    </div>

    <!-- Main content (initially hidden) -->
    <div class="container" id="mainContainer" style="display: none;">
        <div class="status-prefix">
            <span class="desktop-text">Omari is <em class="probably">probably</em></span>
            <span class="mobile-text">Omari<br>is <em class="probably">probably</em></span>
        </div>
        <div class="status-main" id="statusMain"></div>
        
        <div class="status-details" id="statusDetails"></div>
        
    </div>

    <!-- Include shared JavaScript files -->
    <script src="shared-utils.js"></script>
    <script src="shared-particles.js"></script>
    <script src="shared-auth.js"></script>
    <script src="shared-duty-logic.js"></script>
    <script src="shared-modal.js"></script>

    <script>
        // Data storage
        let csvData = null;
        let dutyData = null;
        let parsedCsvData = null;
        let runTransitions = {};
        let updateInterval = null;
        let previousStatus = { main: null, details: null };
        let currentTimetableName = 'N/A';
        let lastPositionForLogging = null;
        
        // Global update buffer to prevent rapid-fire updates
        let updateBuffer = {
            timer: null,
            pendingUpdate: null
        };
        
        // TIMEZONE SETTING - Change this to use different timezone
        const SYSTEM_TIMEZONE = "America/New_York";
        
        // Get current time in the set timezone
        function getCurrentTimeInTimezone(dateTime = null) {
            const now = dateTime || new Date();
            
            try {
                // Get current time in the set timezone
                const localTimeString = now.toLocaleString("en-US", {
                    timeZone: SYSTEM_TIMEZONE,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                
                // Parse the local time string (format: "MM/DD/YYYY, HH:mm:ss")
                const [datePart, timePart] = localTimeString.split(', ');
                const [month, day, year] = datePart.split('/');
                const [hour, minute, second] = timePart.split(':');
                
                const localDateTime = new Date(year, month - 1, day, hour, minute, second);
                
                return localDateTime;
                
            } catch (error) {
                console.error(`[ERROR] getCurrentTimeInTimezone failed:`, error);
                return new Date(); // Fallback to system time
            }
        }

        // Get operating Date object (for timetable selection)
        function getOperatingDateTime(dateTime = null) {
            const localDateTime = getCurrentTimeInTimezone(dateTime || new Date());
            
            // If before 03:00, use previous day as operating date
            if (localDateTime.getHours() < 3) {
                localDateTime.setDate(localDateTime.getDate() - 1);
            }
            
            return localDateTime;
        }
        
        // Main function to initialize app after login
        function initializeApp() {			
            // Show loading overlay
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingOverlay').style.opacity = '1';
            
            console.log('initializeApp called for user:', firebase.auth().currentUser?.email);			
            
            // Hide login screen immediately
            loginSplashScreen.style.opacity = '0';
            setTimeout(() => {
                loginSplashScreen.style.display = 'none';
            }, 500);

            // Show main container immediately
            mainContainer.style.display = 'flex';			
            
            // Load duty tracker, duty lookup data, and initialize modal functionality
            Promise.all([
                fetchDutyTracker(),
                fetchDutyLookupData(),
                initializeModalFunctionality()
            ])
            .then(() => {
                console.log('All data loaded successfully');
                
                // Same timing for overlays...
                setTimeout(() => {
                    const loadingOverlay = document.getElementById('loadingOverlay');
                    if (loadingOverlay) {
                        loadingOverlay.style.opacity = '0';
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 800);
                    }
                }, 3200);				
                
                setTimeout(() => {
                    const textOverlay = document.getElementById('textOverlay');
                    if (textOverlay) {
                        textOverlay.style.opacity = '0';
                        setTimeout(() => {
                            textOverlay.style.display = 'none';
                            document.getElementById('calendarNavButton').style.display = 'block';
                            document.getElementById('signOutButton').style.display = 'block';
                        }, 800);
                    }
                }, 4000);
                
                // Start the real-time updates
                startRealTimeUpdates();
            })
            .catch(error => {
                console.error("Data loading failed:", error);
                
                // Handle error with same timing...
                setTimeout(() => {
                    const loadingOverlay = document.getElementById('loadingOverlay');
                    if (loadingOverlay) {
                        loadingOverlay.style.opacity = '0';
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 800);
                    }
                }, 3200);
                
                setTimeout(() => {
                    const textOverlay = document.getElementById('textOverlay');
                    if (textOverlay) {
                        textOverlay.style.opacity = '0';
                        setTimeout(() => {
                            textOverlay.style.display = 'none';
                        }, 800);
                    }
                    
                    const statusMain = document.getElementById('statusMain');
                    const statusDetails = document.getElementById('statusDetails');
                    
                    if (statusMain) {
                        statusMain.textContent = 'Error loading duty data';
                    }
                    if (statusDetails) {
                        statusDetails.textContent = error.message;
                    }
                }, 4000);
            });
        }
        
        // Start real-time updates
        function startRealTimeUpdates() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            
            // Get initial status immediately (no delay, no animation)
            const currentTimeInTimezone = getCurrentTimeInTimezone();
            const timeStr = currentTimeInTimezone.toTimeString().substring(0, 8);
            const operatingDate = getOperatingDate();
            const status = calculateCurrentStatus(operatingDate, timeStr, currentTimeInTimezone);
            
            // Display initial status immediately
            displayStatus(status.main, status.details, false); 
            previousStatus = { main: status.main, details: status.details };
            
            // Then update every second with normal behavior
            updateInterval = setInterval(updateStatusRealTime, 1000);
        }
        
        // Real-time status update
        function updateStatusRealTime() {
            if (!parsedCsvData || !dutyData) {
                return;
            }
            
            // Get current time in the set timezone instead of system UTC time
            const currentTimeInTimezone = getCurrentTimeInTimezone();
            const timeStr = currentTimeInTimezone.toTimeString().substring(0, 8); // HH:MM:SS
            const operatingDate = getOperatingDate();
            
            // Only log on minute changes to reduce noise
            const minute = currentTimeInTimezone.getMinutes();
            if (minute !== updateStatusRealTime.lastLoggedMinute) {
                const operatingDateTimeForLog = getOperatingDateTime(currentTimeInTimezone);
                console.log(`[DEBUG] updateStatusRealTime called at:`, {
                    utcTime: new Date().toISOString(),
                    timezoneTime: currentTimeInTimezone.toISOString(),
                    operatingDate: operatingDate,
                    operatingDayOfWeek: operatingDateTimeForLog.toLocaleDateString('en-US', { weekday: 'long' }),
                    timeStr,
                    dayOfWeek: currentTimeInTimezone.toLocaleDateString('en-US', { weekday: 'long' }),
                    hour: currentTimeInTimezone.getHours(),
                    timetable: currentTimetableName
                });
                updateStatusRealTime.lastLoggedMinute = minute;
            }
            
            const status = calculateCurrentStatus(operatingDate, timeStr, currentTimeInTimezone);
            
            // Check if this is just a countdown update vs a meaningful status change
            const isCountdownUpdate = isOnlyCountdownChange(previousStatus, status);
            
            // Only animate if the status meaningfully changed (not just countdown)
            if (status.main !== previousStatus.main || status.details !== previousStatus.details) {
                displayStatus(status.main, status.details, !isCountdownUpdate); // animate only if not countdown
                previousStatus = { main: status.main, details: status.details };
            }
        }
        
        function findNextDuty(currentOperatingDate, currentTime, currentDateTime) {
            const lines = dutyData.split('\n');
            
            // First, find the index of the current operating date to start searching from there
            let startIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === currentOperatingDate + ':') {
                    startIndex = i;
                    break;
                }
            }
            
            if (startIndex === -1) {
                return null;
            }
            
            // Parse duty data starting from current date, looking ahead up to 30 days
            const allDuties = [];
            let dateCount = 0;
            const maxDatesToCheck = 30; // Reasonable limit
            
            for (let i = startIndex; i < lines.length && dateCount < maxDatesToCheck; i++) {
                const line = lines[i].trim();
                if (line.endsWith(':')) {
                    dateCount++;
                    const date = line.slice(0, -1);
                    const category = lines[i + 1]?.trim();
                    const dutyNumber = lines[i + 2]?.trim(); // New duty number line
                    
                    let firstHalf = '';
                    let secondHalf = '';
                    
                    // Only read duty details for working categories
                    if (category && !['O', 'AL', 'OAL', 'LD', 'BH'].includes(category)) {
                        firstHalf = lines[i + 3]?.trim() || ''; // Shifted by 1
                        secondHalf = lines[i + 4]?.trim() || ''; // Shifted by 1
                    }
                    
                    if (category && !['O', 'AL', 'OAL', 'LD', 'BH'].includes(category)) {
                        // This is a working duty
                        let nextPickupTime = null;
                        let nextPickupLocation = null;
                        
                        // Find the earliest pickup time from first/second half
                        if (firstHalf && firstHalf !== 'SPARE') {
                            const firstHalfInfo = parseRunInfo(firstHalf);
                            if (firstHalfInfo) {
                                nextPickupTime = firstHalfInfo.startTime;
                                nextPickupLocation = getLocationName(firstHalfInfo.startLocation);
                            }
                        }
                        
                        if (secondHalf && secondHalf !== 'SPARE') {
                            const secondHalfInfo = parseRunInfo(secondHalf);
                            if (secondHalfInfo) {
                                const secondHalfStart = secondHalfInfo.startTime;
                                if (!nextPickupTime || secondHalfStart < nextPickupTime) {
                                    nextPickupTime = secondHalfStart;
                                    nextPickupLocation = getLocationName(secondHalfInfo.startLocation);
                                }
                            }
                        }
                        
                        if (nextPickupTime && nextPickupLocation) {
                            // Add seconds if not present, don't double-add
                            const timeWithSeconds = nextPickupTime.includes(':') && nextPickupTime.split(':').length === 2 
                                ? nextPickupTime + ':00' 
                                : nextPickupTime;
                            
                            // Create duty datetime in local time (no timezone conversion)
                            const dutyDateTime = new Date(`${date}T${timeWithSeconds}`);
                            
                            if (dutyDateTime > currentDateTime) {
                                allDuties.push({
                                    date: date,
                                    time: nextPickupTime,
                                    location: nextPickupLocation,
                                    dateTime: dutyDateTime
                                });
                            }
                        }
                    }
                }
            }
            
            // Sort by date/time and return the next one
            allDuties.sort((a, b) => a.dateTime - b.dateTime);
            const result = allDuties.length > 0 ? allDuties[0] : null;
            return result;
        }
        
        function formatNextDutyDate(nextDuty, currentDateTime) {
            const nextDate = new Date(nextDuty.dateTime);
            const today = new Date(currentDateTime);
            today.setHours(0, 0, 0, 0);

            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            const nextDateOnly = new Date(nextDate);
            nextDateOnly.setHours(0, 0, 0, 0);

            const timeStr = nextDuty.time.substring(0, 5); // Strip seconds from time

            const getWeekNumber = (date) => {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                d.setDate(d.getDate() + 4 - (d.getDay() || 7));
                const yearStart = new Date(d.getFullYear(), 0, 1);
                return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            };

            if (+nextDateOnly === +today) {
                return `today at ${timeStr}`;
            } else if (+nextDateOnly === +tomorrow) {
                return `tomorrow at ${timeStr}`;
            }

            const dayName = nextDate.toLocaleDateString('en-US', { weekday: 'long' });
            const nextWeekNum = getWeekNumber(nextDateOnly);
            const currentWeekNum = getWeekNumber(today);

            if (nextWeekNum === currentWeekNum) {
                return `on ${dayName} at ${timeStr}`;
            } else if (nextWeekNum === currentWeekNum + 1) {
                return `on ${dayName} next week at ${timeStr}`;
            } else {
                const day = nextDate.getDate();
                const suffix = day % 10 === 1 && day !== 11 ? 'st' :
                              day % 10 === 2 && day !== 12 ? 'nd' :
                              day % 10 === 3 && day !== 13 ? 'rd' : 'th';
                const month = nextDate.toLocaleDateString('en-US', { month: 'long' });
                return `on the ${day}${suffix} of ${month} at ${timeStr}`;
            }
        }
        
        // *** MODIFIED ***: Correctly adjusts current time for comparison with timetable
        function calculateCurrentStatus(operatingDate, time, currentDateTime) {
            // Parse duty data for the given operating date
            const lines = dutyData.split('\n');
            let currentDateData = null;
            let foundDate = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === operatingDate + ':') {
                    foundDate = true;
                    const category = lines[i + 1]?.trim();
                    
                    if (['O', 'AL', 'OAL', 'LD', 'BH'].includes(category)) {
                        currentDateData = {
                            category: category,
                            firstHalf: '',
                            secondHalf: ''
                        };
                    } else {
                        currentDateData = {
                            category: category,
                            firstHalf: lines[i + 3]?.trim() || '',
                            secondHalf: lines[i + 4]?.trim() || ''
                        };
                    }
                    break;
                }
            }
            
            if (!foundDate) {
                return {
                    main: 'not on the DLR right now',
                    details: 'No duty information found for this date'
                };
            }
            
            if (['O', 'AL', 'OAL', 'LD', 'BH'].includes(currentDateData.category)) {
                const nextDuty = findNextDuty(operatingDate, time, currentDateTime);
                if (nextDuty) {
                    const whenText = formatNextDutyDate(nextDuty, currentDateTime);
                    return {
                        main: 'not on the DLR right now',
                        details: `He'll be back at ${nextDuty.location} ${whenText}`
                    };
                } else {
                    return {
                        main: 'not on the DLR right now',
                        details: 'No upcoming duties found'
                    };
                }
            }
            
            if (currentDateData.firstHalf === 'SPARE' && currentDateData.secondHalf === 'SPARE') {
                return {
                    main: 'somewhere on the DLR',
                    details: 'On a Spare duty'
                };
            }

            // --- TIME ADJUSTMENT LOGIC ---
            // If the current calendar day is after the operating day (e.g., 2 AM Monday for Sunday's duty),
            // add 24 hours to the time so it can be correctly compared with timetable times like "26:30:00".
            let adjustedTime = time;
            const operatingDateStr = operatingDate; // e.g., "2025-06-08"
            const currentDateStr = currentDateTime.toISOString().split('T')[0]; // e.g., "2025-06-09"

            if (currentDateStr > operatingDateStr) {
                 const [hours, minutes, seconds] = time.split(':').map(Number);
                 const adjustedHours = hours + 24;
                 adjustedTime = `${adjustedHours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            const currentTimeSeconds = parseTime(adjustedTime);
            // --- END TIME ADJUSTMENT ---

            // Check first half
            if (currentDateData.firstHalf && currentDateData.firstHalf !== 'SPARE') {
                const firstHalf = parseRunInfo(currentDateData.firstHalf);
                if (firstHalf) {
                    const startDateTime = convertDutyTimeToDateTime(operatingDate, firstHalf.startTime);
                    const endDateTime = convertDutyTimeToDateTime(operatingDate, firstHalf.endTime);
                    
                    if (currentDateTime >= startDateTime && currentDateTime <= endDateTime) {
                        return getRunStatus(firstHalf, currentTimeSeconds, time);
                    }
                }
            }
            
            // Check second half
            if (currentDateData.secondHalf && currentDateData.secondHalf !== 'SPARE') {
                const secondHalf = parseRunInfo(currentDateData.secondHalf);
                if (secondHalf) {
                    const startDateTime = convertDutyTimeToDateTime(operatingDate, secondHalf.startTime);
                    const endDateTime = convertDutyTimeToDateTime(operatingDate, secondHalf.endTime);
                    
                    if (currentDateTime >= startDateTime && currentDateTime <= endDateTime) {
                        return getRunStatus(secondHalf, currentTimeSeconds, time);
                    }
                }
            }
            
            // Check if between duties (on break)
            if (currentDateData.firstHalf && currentDateData.secondHalf && 
                currentDateData.firstHalf !== 'SPARE' && currentDateData.secondHalf !== 'SPARE') {
                const firstHalf = parseRunInfo(currentDateData.firstHalf);
                const secondHalf = parseRunInfo(currentDateData.secondHalf);
                
                if (firstHalf && secondHalf) {
                    const firstEndDateTime = convertDutyTimeToDateTime(operatingDate, firstHalf.endTime);
                    const secondStartDateTime = convertDutyTimeToDateTime(operatingDate, secondHalf.startTime);
                    
                    if (currentDateTime > firstEndDateTime && currentDateTime < secondStartDateTime) {
                        return {
                            main: 'on break',
                            details: `Next service: Run ${secondHalf.runNumber} at ${secondHalf.startTime} at ${getLocationName(secondHalf.startLocation)}`
                        };
                    }
                }
            }
            
            // Default case - not currently on duty, find next pickup
            const nextDuty = findNextDuty(operatingDate, time, currentDateTime);
            if (nextDuty) {
                const whenText = formatNextDutyDate(nextDuty, currentDateTime);
                return {
                    main: 'not on the DLR right now',
                    details: `He'll be back at ${nextDuty.location} ${whenText}`
                };
            } else {
                return {
                    main: 'not on the DLR right now',
                    details: 'No upcoming duties found'
                };
            }
        }
        
        // Enhanced getRunStatus function with base/non-base duty detection
        function getRunStatus(runInfo, currentTimeSeconds, timeStr) {
            // Get duty versions to check if it's a base duty
            const operatingDate = getOperatingDate();
            const dutyVersions = getDutyForDate(runInfo.firstRun, operatingDate);
            const isBaseDuty = dutyVersions.length > 0 && isDutyBaseType(dutyVersions[0]);
            
            // SIMPLE RULE: Don't start position updates until 1 minute after pickup time
            const dutyStartTimeSeconds = parseTime(runInfo.startTime);
            const oneMinuteAfterStart = dutyStartTimeSeconds + 60;
            
            if (currentTimeSeconds < oneMinuteAfterStart) {
                // We're still in the "pickup period" - show simple departing status
                const startLocationName = getLocationName(runInfo.startLocation);
                
                // Handle run transitions to get the right run number
                let actualRunNumber = runInfo.firstRun;
                let displayRunNumber = runInfo.runNumber;
                
                if (runInfo.secondRun && runInfo.transitionTime && currentTimeSeconds > runInfo.transitionTime) {
                    actualRunNumber = runInfo.secondRun;
                    displayRunNumber = actualRunNumber;
                }
                
                // Get simple destination
                let destination;
                if (isBaseDuty && parsedCsvData[actualRunNumber]) {
                    const lastStop = parsedCsvData[actualRunNumber][parsedCsvData[actualRunNumber].length - 1];
                    destination = lastStop.location;
                } else {
                    destination = getLocationName(runInfo.endLocation);
                }
                
                return {
                    main: `departing ${startLocationName}`,
                    details: `onboard Run ${displayRunNumber} to ${destination}`
                };
            }
            
            // If it's not a base duty, use fallback logic
            if (!isBaseDuty) {
                const startLocationName = getLocationName(runInfo.startLocation);
                const endLocationName = getLocationName(runInfo.endLocation);
                const displayRunNumber = runInfo.runNumber;
                
                return {
                    main: 'somewhere on the DLR',
                    details: `onboard Run ${displayRunNumber} which picked up from ${startLocationName} at ${runInfo.startTime.substring(0, 5)} and is relieved at ${endLocationName} at ${runInfo.endTime.substring(0, 5)}`
                };
            }
            
            // Continue with existing base duty logic...
            // Handle run transitions
            let actualRunNumber = runInfo.firstRun;
            let displayRunNumber = runInfo.runNumber;
            
            if (runInfo.secondRun && runInfo.transitionTime) {
                // Check if we're in the transition gap
                if (currentTimeSeconds > runInfo.transitionTime) {
                    // We're after the first run ended, check if second run has started
                    const secondRunStops = parsedCsvData[runInfo.secondRun];
                    if (secondRunStops && secondRunStops.length > 0) {
                        const secondRunStartTime = parseTime(secondRunStops[0].arrivalTime);
                        
                        if (currentTimeSeconds < secondRunStartTime) {
                            // We're in the transition gap - between runs
                            const firstRunStops = parsedCsvData[runInfo.firstRun];
                            if (firstRunStops && firstRunStops.length > 0) {
                                const lastStopFirstRun = firstRunStops[firstRunStops.length - 1];
                                const firstStopSecondRun = secondRunStops[0];
                                
                                return {
                                    main: `between ${lastStopFirstRun.location} and ${firstStopSecondRun.location}`,
                                    details: `Transitioning from Run ${runInfo.firstRun} to Run ${runInfo.secondRun}`
                                };
                            }
                        } else {
                            // Second run has started, use second run
                            actualRunNumber = runInfo.secondRun;
                        }
                    }
                }
                // If we're still before transition time, continue using first run
                displayRunNumber = actualRunNumber; // Show the actual run number being used
            }
            
            // Check if we have this run in our CSV data
            if (!parsedCsvData[actualRunNumber]) {
                // Regular operating service without timetable
                const startStation = getLocationName(runInfo.startLocation);
                const endStation = getLocationName(runInfo.endLocation);
                
                return {
                    main: `operating between ${startStation} and ${endStation}`,
                    details: `onboard Run ${displayRunNumber} - timetable not available`
                };
            }
            
            // Get the destination for this trip (not the entire run)
            const destination = getCurrentTripDestination(actualRunNumber, currentTimeSeconds);
            
            // Find current position in the timetable
            const currentPosition = findCurrentPosition(parsedCsvData[actualRunNumber], timeStr, currentTimeSeconds);
            
            if (currentPosition.type === 'at_station') {
                let details = '';
                if (currentPosition.details === 'departing soon') {
                    details = `onboard Run ${displayRunNumber} to ${destination} - departing soon`;
                } else if (currentPosition.details.includes('minute')) {
                    details = `onboard Run ${displayRunNumber} to ${destination} - ${currentPosition.details}`;
                } else {
                    // This covers "departing now" which we're removing - treat as departing soon
                    details = `onboard Run ${displayRunNumber} to ${destination} - departing soon`;
                }
                
                return {
                    main: `at ${currentPosition.location}`,
                    details: details
                };
            } else if (currentPosition.type === 'departing_station') {
                return {
                    main: `departing ${currentPosition.location}`,
                    details: `onboard Run ${displayRunNumber} to ${destination}`
                };
            } else if (currentPosition.type === 'approaching_station') {
                return {
                    main: `approaching ${currentPosition.to}`,
                    details: `onboard Run ${displayRunNumber} to ${destination}`
                };
            } else if (currentPosition.type === 'between_stations') {
                return {
                    main: `between ${currentPosition.from} and ${currentPosition.to}`,
                    details: `onboard Run ${displayRunNumber} to ${destination}`
                };
            } else {
                // Existing fallback logic for depot movements...
                const startLocation = runInfo.startLocation;
                const endLocation = runInfo.endLocation;
                
                if (['POD', 'BED'].includes(startLocation) || ['POD', 'BED'].includes(endLocation)) {
                    if (['POD', 'BED'].includes(startLocation)) {
                        // Empty stock leaving depot
                        const depot = getDepotName(startLocation);
                        let dutyStartTime = runInfo.startTime.substring(0, 5);
                        
                        // Convert 25:55 format to 01:55 for display  
                        if (dutyStartTime.startsWith('2') && parseInt(dutyStartTime.split(':')[0]) >= 24) {
                            const [hours, minutes] = dutyStartTime.split(':');
                            const adjustedHours = (parseInt(hours) - 24).toString().padStart(2, '0');
                            dutyStartTime = `${adjustedHours}:${minutes}`;
                        }
                        
                        const firstStation = getRunFirstStation(actualRunNumber);
                        
                        if (firstStation) {
                            let firstStationTime = firstStation.time.substring(0, 5);
                            if (firstStationTime.startsWith('2') && parseInt(firstStationTime.split(':')[0]) >= 24) {
                                const [hours, minutes] = firstStationTime.split(':');
                                const adjustedHours = (parseInt(hours) - 24).toString().padStart(2, '0');
                                firstStationTime = `${adjustedHours}:${minutes}`;
                            }
                            
                            return {
                                main: 'somewhere on the DLR',
                                details: `onboard a train that left ${depot} at ${dutyStartTime}, and will form Run ${actualRunNumber} when it reaches ${firstStation.location} at ${firstStationTime}`
                            };
                        } else {
                            return {
                                main: 'somewhere on the DLR',
                                details: `onboard a train that left ${depot} at ${dutyStartTime}, and will form Run ${actualRunNumber}`
                            };
                        }
                    } else {
                        // Empty stock returning to depot
                        const depot = getDepotName(endLocation);
                        let dutyEndTime = runInfo.endTime.substring(0, 5);
                        
                        // Convert 25:55 format to 01:55 for display
                        if (dutyEndTime.startsWith('2') && parseInt(dutyEndTime.split(':')[0]) >= 24) {
                            const [hours, minutes] = dutyEndTime.split(':');
                            const adjustedHours = (parseInt(hours) - 24).toString().padStart(2, '0');
                            dutyEndTime = `${adjustedHours}:${minutes}`;
                        }
                        
                        const lastStation = getRunLastStation(actualRunNumber);
                        
                        if (lastStation) {
                            let lastStationTime = lastStation.time.substring(0, 5);
                            // Convert last station time too if needed
                            if (lastStationTime.startsWith('2') && parseInt(lastStationTime.split(':')[0]) >= 24) {
                                const [hours, minutes] = lastStationTime.split(':');
                                const adjustedHours = (parseInt(hours) - 24).toString().padStart(2, '0');
                                lastStationTime = `${adjustedHours}:${minutes}`;
                            }
                            
                            return {
                                main: 'somewhere on the DLR',
                                details: `onboard a train due into ${depot} at ${dutyEndTime}, it was formally Run ${actualRunNumber} which the timetable for ended when it reached ${lastStation.location} at ${lastStationTime}`
                            };
                        } else {
                            return {
                                main: 'somewhere on the DLR',
                                details: `onboard a train due into ${depot} at ${dutyEndTime}, it was formally Run ${actualRunNumber}`
                            };
                        }
                    }
                }
                
                // Fallback to simple calculation
                const startStation = getLocationName(runInfo.startLocation);
                const endStation = getLocationName(runInfo.endLocation);
                const runStartTimeSeconds = parseTime(runInfo.startTime);
                const runEndTimeSeconds = parseTime(runInfo.endTime);
                const elapsed = currentTimeSeconds - runStartTimeSeconds;
                const duration = runEndTimeSeconds - runStartTimeSeconds;
                const progress = elapsed / duration;
                
                if (progress < 0.3) {
                    return {
                        main: `departing ${startStation}`,
                        details: `onboard Run ${displayRunNumber} to ${destination}`
                    };
                } else if (progress > 0.8) {
                    return {
                        main: `approaching ${endStation}`,
                        details: `onboard Run ${displayRunNumber} to ${destination}`
                    };
                } else {
                    return {
                        main: `between ${startStation} and ${endStation}`,
                        details: `onboard Run ${displayRunNumber} to ${destination}`
                    };
                }
            }
        }
        
        // Get the destination for current trip within a run - SIMPLIFIED
        function getCurrentTripDestination(runNumber, currentTimeSeconds) {
            if (!parsedCsvData[runNumber] || parsedCsvData[runNumber].length === 0) {
                console.log(`[DEBUG] No data for run ${runNumber}`);
                return null;
            }
            
            const stops = parsedCsvData[runNumber];
            const trips = detectTrips(stops);
            
            // Find which trip we're currently in
            for (const trip of trips) {
                const tripStartTime = parseTime(trip.departureTime);
                const tripEndTime = parseTime(trip.arrivalTime);
                
                if (currentTimeSeconds >= tripStartTime && currentTimeSeconds <= tripEndTime) {
                    return trip.to;
                }
            }
            
            // If we're not in any trip, find the next upcoming trip
            for (const trip of trips) {
                const tripStartTime = parseTime(trip.departureTime);
                if (currentTimeSeconds < tripStartTime) {
                    console.log(`[DEBUG] Next trip destination: ${trip.to}`);
                    return trip.to;
                }
            }
            
            // Fallback: return the final destination of the entire run
            const finalDestination = stops[stops.length - 1].location;
            console.log(`[DEBUG] Fallback destination: ${finalDestination}`);
            return finalDestination;
        }
        
        function getRunFirstStation(runNumber) {
            if (!parsedCsvData[runNumber] || parsedCsvData[runNumber].length === 0) {
                return null;
            }
            const firstStop = parsedCsvData[runNumber][0];
            return {
                location: firstStop.location,
                time: firstStop.arrivalTime
            };
        }
        
        function getRunLastStation(runNumber) {
            if (!parsedCsvData[runNumber] || parsedCsvData[runNumber].length === 0) {
                return null;
            }
            const lastStop = parsedCsvData[runNumber][parsedCsvData[runNumber].length - 1];
            return {
                location: lastStop.location,
                time: lastStop.arrivalTime
            };
        }
        
        // Detect trips within a run (from timetable explorer)
        function detectTrips(stops) {
            const trips = [];
            let currentTrip = [];
            let tripNumber = 1;

            for (let i = 0; i < stops.length; i++) {
                currentTrip.push(stops[i]);

                if (i < stops.length - 2) {
                    const loc1 = stops[i].location;
                    const loc2 = stops[i + 1].location;
                    const loc3 = stops[i + 2].location;

                    if (loc1 === loc3 && loc1 !== loc2) {
                        trips.push({
                            tripNumber,
                            from: currentTrip[0].location,
                            departureTime: currentTrip[0].departureTime,
                            to: loc2,
                            arrivalTime: stops[i + 1].arrivalTime,
                            stops: [...currentTrip, stops[i + 1]]
                        });
                        
                        currentTrip = [stops[i + 1]];
                        tripNumber++;
                        i++;
                    }
                }
            }

            if (currentTrip.length > 0) {
                trips.push({
                    tripNumber,
                    from: currentTrip[0].location,
                    departureTime: currentTrip[0].departureTime,
                    to: currentTrip[currentTrip.length - 1].location,
                    arrivalTime: currentTrip[currentTrip.length - 1].arrivalTime,
                    stops: [...currentTrip]
                });
            }

            return trips;
        }
        
        // Logs the raw CSV line for debugging
        function findCurrentPosition(runStops, currentTime, currentTimeSeconds) {
            
            // Find the current position in the timetable
            for (let i = 0; i < runStops.length; i++) {
                const stop = runStops[i];
                const arrivalTime = parseTime(stop.arrivalTime);
                const departureTime = parseTime(stop.departureTime);
                
                // Check if we're in the "departing" window (0 seconds before departure, lasting 20 seconds)
                if (currentTimeSeconds >= (departureTime - 0) && currentTimeSeconds <= (departureTime + 20)) {
                    const currentPosition = `departing-${stop.location}`;
                    if (lastPositionForLogging !== currentPosition) {
                        console.log(`[DEBUG] Departing station. Timetable line:`, stop.rawLine);
                        lastPositionForLogging = currentPosition;
                    }					
                    return {
                        type: 'departing_station',
                        location: stop.location
                    };
                }
                
                // If we're at a station (between arrival and departure, but not in departing window)
                if (currentTimeSeconds >= arrivalTime && currentTimeSeconds < departureTime) {
                    const secondsToDeparture = departureTime - currentTimeSeconds;
                    let details = '';
                    if (secondsToDeparture > 60) {
                        const minutesToDeparture = Math.floor(secondsToDeparture / 60);
                        details = `departing in ${minutesToDeparture} minute${minutesToDeparture !== 1 ? 's' : ''}`;
                    } else {
                        // Anything 60 seconds or less becomes "departing soon"
                        details = 'departing soon';
                    }
                    const currentPosition = `at-${stop.location}`;
                    if (lastPositionForLogging !== currentPosition) {
                        console.log(`[DEBUG] At station. Timetable line:`, stop.rawLine);
                        lastPositionForLogging = currentPosition;
                    }					
                    return {
                        type: 'at_station',
                        location: stop.location,
                        details: details
                    };
                }
                
                // If we're between this station and the next
                if (i < runStops.length - 1) {
                    const nextStop = runStops[i + 1];
                    const nextArrivalTime = parseTime(nextStop.arrivalTime);
                    
                    // SAFETY CHECK: Prevent "between X and X" errors
                    if (stop.location === nextStop.location) {
                        console.log(`[DEBUG] Skipping duplicate station: ${stop.location}`);
                        continue; // Skip to next iteration
                    }

                    // Check if we're in the "approaching" window (20 seconds before arrival)
                    if (currentTimeSeconds >= (nextArrivalTime - 20) && currentTimeSeconds < nextArrivalTime) {
                        const currentPosition = `approaching-${stop.location}-${nextStop.location}`;
                        if (lastPositionForLogging !== currentPosition) {
                            console.log(`[DEBUG] Approaching station. From line:`, stop.rawLine, 'To line:', nextStop.rawLine);
                            lastPositionForLogging = currentPosition;
                        }
                        return {
                            type: 'approaching_station',
                            from: stop.location,
                            to: nextStop.location
                        };
                    }
                    
                    // Regular between stations (after departure + 20 seconds, before approaching window)
                    if (currentTimeSeconds > (departureTime + 20) && currentTimeSeconds < (nextArrivalTime - 20)) {
                        const currentPosition = `between-${stop.location}-${nextStop.location}`;
                        if (lastPositionForLogging !== currentPosition) {
                            console.log(`[DEBUG] Between stations. From line:`, stop.rawLine, 'To line:', nextStop.rawLine);
                            lastPositionForLogging = currentPosition;
                        }
                        
                        return {
                            type: 'between_stations',
                            from: stop.location,
                            to: nextStop.location
                        };
                    }
                }
            }
            
            return { type: 'unknown' };
        }
        
        // Enhanced displayStatus function that makes run numbers clickable
        function displayStatus(main, details, animate = false) {
            // Clear any existing timer
            if (updateBuffer.timer) {
                clearTimeout(updateBuffer.timer);
            }
            
            // Store the pending update
            updateBuffer.pendingUpdate = { main, details, animate };
            
            // Set a 3-second timer
            updateBuffer.timer = setTimeout(() => {
                const update = updateBuffer.pendingUpdate;
                if (!update) return;
                
                // Update particle speed based on status
                updateParticleSpeed({ main: update.main, details: update.details });
                
                const statusMain = document.getElementById('statusMain');
                const statusDetails = document.getElementById('statusDetails');
                const loadingState = document.getElementById('loadingState');
                
                // Safety checks
                if (!statusMain || !statusDetails) return;

                // Log every time the status text is updated on screen
                console.log(`[${new Date().toLocaleTimeString()}] Status updated: "${update.main}" | "${update.details}"`);
                
                // Hide loading if it exists
                if (loadingState) {
                    loadingState.style.display = 'none';
                }
                
                // If not animating, just update text directly
                if (!update.animate) {
                    statusMain.textContent = update.main;
                    statusDetails.textContent = update.details;
                    
                    // Make run numbers clickable after setting text
                    const operatingDate = getOperatingDate();
                    makeRunNumbersClickable(statusDetails, operatingDate);
                    return;
                }
                
                // Clear any existing animations and classes
                statusMain.style.animation = 'none';
                statusMain.classList.remove('status-change');
                statusDetails.style.animation = 'none';
                statusDetails.classList.remove('details-fade-out', 'details-fade-in');
                
                // Phase 1: Fade out statusMain
                statusMain.style.opacity = '0';
                statusMain.style.transform = 'translateY(10px)';
                statusMain.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
                
                // Phase 2: Change statusMain text and fade in
                setTimeout(() => {
                    statusMain.textContent = update.main;
                    statusMain.style.opacity = '1';
                    statusMain.style.transform = 'translateY(0)';
                    statusMain.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
                    
                    // Clean up statusMain transition
                    setTimeout(() => {
                        statusMain.style.transition = '';
                    }, 600);
                }, 400);
                
                // Phase 3: Animate statusDetails using CSS classes with proper cleanup
                setTimeout(() => {
                    // Force reflow to ensure animation clearing takes effect
                    statusDetails.offsetHeight;
                    
                    // Start fade out
                    statusDetails.classList.add('details-fade-out');
                    
                    // Change text and fade in after fade out completes
                    setTimeout(() => {
                        statusDetails.textContent = update.details;
                        statusDetails.classList.remove('details-fade-out');
                        
                        // Force reflow before applying fade in
                        statusDetails.offsetHeight;
                        
                        statusDetails.classList.add('details-fade-in');
                        
                        // Clean up after animation and restore normal CSS behavior
                        setTimeout(() => {
                            statusDetails.classList.remove('details-fade-in');
                            statusDetails.style.animation = ''; // Reset to CSS default
                            
                            // Make run numbers clickable after animation completes
                            const operatingDate = getOperatingDate();
                            makeRunNumbersClickable(statusDetails, operatingDate);
                        }, 400);
                    }, 300);
                }, 700);
                
                // Clear the pending update
                updateBuffer.pendingUpdate = null;
                updateBuffer.timer = null;
            }, 3000);
        }
        
        // --- TIMETABLE FETCHING LOGIC ---

        function parseDateRange(dateStr) {
            dateStr = dateStr.replace(/['"]/g, '');
            if (dateStr.includes('/')) {
                const [start, end] = dateStr.split('/').map(d => new Date(d.trim()));
                return { start, end };
            }
            const date = new Date(dateStr);
            return { start: date, end: date };
        }

        function getDayName(date) {
            return date.toLocaleDateString('en-US', { weekday: 'long' });
        }

        function isDateInRange(date, rangeStr) {
            const ranges = rangeStr.split(',').map(r => r.trim().replace(/['"]/g, ''));
            return ranges.some(range => {
                if (['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].includes(range)) {
                    return getDayName(date) === range;
                }
                const dateRange = parseDateRange(range);
                return date >= dateRange.start && date <= dateRange.end;
            });
        }
        
        // Uses getOperatingDateTime to ensure correct day is used
        function sortTimetablesByApplicability(entries) {
            const operatingDateTime = getOperatingDateTime(); // Use operating day logic
            const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return entries.sort((a, b) => {
                const aApplies = a.applies.split(',').map(s => s.trim().replace(/['"]/g, ''));
                const bApplies = b.applies.split(',').map(s => s.trim().replace(/['"]/g, ''));
                
                const aHasSpecificDate = aApplies.some(range => !dayNames.includes(range));
                const bHasSpecificDate = bApplies.some(range => !dayNames.includes(range));
                
                const aAppliesNow = aApplies.some(range => isDateInRange(operatingDateTime, range));
                const bAppliesNow = bApplies.some(range => isDateInRange(operatingDateTime, range));
                
                if (aAppliesNow && bAppliesNow) {
                    if (aHasSpecificDate && !bHasSpecificDate) return -1;
                    if (!aHasSpecificDate && bHasSpecificDate) return 1;
                }
                
                if (aAppliesNow && !bAppliesNow) return -1;
                if (!aAppliesNow && bAppliesNow) return 1;
                
                return a.name.localeCompare(b.name);
            });
        }

        async function fetchAndProcessTimetable() {
            const pathsUrl = 'https://raw.githubusercontent.com/dlrttbl/dlrttbl.github.io/refs/heads/main/paths.txt';
            
            try {
                // 1. Fetch paths.txt
                const response = await fetch(pathsUrl, { cache: 'no-store' });
                if (!response.ok) throw new Error(`Failed to fetch paths.txt: ${response.statusText}`);
                const text = await response.text();
                const lines = text.split('\n').filter(line => line.trim() !== '');

                // 2. Parse paths.txt to get timetable entries
                let currentEntry = {};
                const timetableEntries = [];
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('Name:')) {
                        if (Object.keys(currentEntry).length > 0) timetableEntries.push({...currentEntry});
                        currentEntry = { name: trimmedLine.substring(5).trim() };
                    } else if (trimmedLine.startsWith('Applies:')) {
                        currentEntry.applies = trimmedLine.substring(8).trim();
                    } else if (trimmedLine.startsWith('URL:')) {
                        currentEntry.url = trimmedLine.substring(4).trim();
                    }
                }
                if (Object.keys(currentEntry).length > 0) timetableEntries.push(currentEntry);

                if (timetableEntries.length === 0) {
                    throw new Error('No valid timetables found in paths.txt');
                }

                // 3. Determine the most applicable timetable
                const sortedEntries = sortTimetablesByApplicability(timetableEntries);
                const applicableTimetable = sortedEntries[0];
                currentTimetableName = applicableTimetable.name;
                console.log(`[INFO] Using timetable: '${currentTimetableName}' from URL: ${applicableTimetable.url}`);

                // 4. Fetch the applicable timetable CSV
                const csvResponse = await fetch(applicableTimetable.url, { cache: 'no-store' });
                if (!csvResponse.ok) throw new Error(`Failed to fetch timetable CSV: ${csvResponse.statusText}`);
                const csvText = await csvResponse.text();

                // 5. Process the CSV data
                csvData = csvText;
                parsedCsvData = parseCSVData(csvData);
                runTransitions = detectRunTransitions(csvData);
                console.log('Timetable data loaded and parsed automatically.');

            } catch (error) {
                console.error('[ERROR] Automatic timetable fetching failed:', error);
                throw error;
            }
        }
        
        // Parse CSV data
        function parseCSVData(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            const runData = {};
            
            const junctions = [
                'JRMS', 'JRMX', 'JCAW', 'JWEM', 'JCRO', 'JC2M', 'JC3M',
                'JC4M', 'JROM', 'JWEX', 'JCTM', 'JCTX', 'JWIQ', 'JNQX',
                'JNQM', 'JWSX', 'JWSM', 'ISP2', 'ISP3'
            ];
            
            lines.forEach((line, index) => {
                const parts = line.split(',');
                if (parts.length >= 7) {
                    const runNumber = parts[1].trim();
                    const locationCode = parts[4].trim();
                    const arrivalTime = parts[5].trim();
                    const departureTime = parts[6].trim();
                    
                    if (!junctions.includes(locationCode)) {
                        if (!runData[runNumber]) {
                            runData[runNumber] = [];
                        }
                        
                        let location = '';
                        let platform = '';
                        
                        if (locationCode === 'BANH') {
                            location = 'Bank Headshunt';
                        } else {
                            const codePrefix = locationCode.slice(0, 3);
                            platform = locationCode.slice(3);
                            
                            if (locationMapping[codePrefix]) {
                                location = locationMapping[codePrefix];
                                if (['LEW', 'BEC', 'STI', 'WOA'].includes(codePrefix) || locationCode === 'STR4B') {
                                    platform = '';
                                }
                            } else {
                                location = locationCode;
                                platform = '';
                            }
                        }
                        
                        runData[runNumber].push({
                            location,
                            platform,
                            arrivalTime,
                            departureTime,
                            locationCode,
                            rawLine: line // Store original line
                        });
                    }
                }
            });
            
            return runData;
        }
        
        // Detect run transitions
        function detectRunTransitions(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            const transitions = {};
            
            // Adjacency map of DLR stations
            const adjacencyMap = {
                "ABR": ["SHS", "WEH"], "ALS": ["LAP", "POP"], "BAN": ["SHA", "BANH"],
                "BANH": ["BAN"], "BEC": ["GAR"], "BEP": ["CYP", "ROA"],
                "BLA": ["EAI", "POP"], "BOC": ["DER", "PML"], "CAT": ["EAI", "ROV", "STL", "WST"],
                "CAW": ["HEQ", "WES", "WIQ"], "CRO": ["MUD", "SOQ"], "CUH": ["PRR", "ROV"],
                "CUS": ["GRE", "ISG"], "CYP": ["BEP", "GAR"], "DEB": ["ELR", "GRE"],
                "DER": ["BOC", "LAP"], "EAI": ["BLA", "CAT"], "ELR": ["DEB", "LEW"],
                "GAR": ["BEC", "CYP"], "GRE": ["CUS", "DEB"], "HEQ": ["CAW", "SOQ"],
                "ISG": ["CUS", "MUD"], "KGV": ["LCA", "WOA"], "LAP": ["ALS", "DER"],
                "LCA": ["KGV", "PDK"], "LEW": ["ELR"], "LIM": ["SHA", "WES"],
                "MUD": ["CRO", "ISG"], "PDK": ["LCA", "WST"], "PML": ["BOC", "STR"],
                "POP": ["ALS", "BLA", "WES", "WIQ"], "PRR": ["CUH", "ROA"], "ROA": ["BEP", "PRR"],
                "ROV": ["CAT", "CUH"], "SHA": ["BAN", "LIM", "TOG"], "SHS": ["ABR", "STR"],
                "SOQ": ["CRO", "HEQ"], "STI": ["STR"], "STL": ["CAT", "WEH"],
                "STR": ["PML", "SHS", "STI"], "TOG": ["SHA"], "WEH": ["ABR", "STL"],
                "WES": ["CAW", "LIM", "POP", "WIQ"], "WIQ": ["CAW", "POP", "WES"],
                "WOA": ["KGV"], "WST": ["CAT", "PDK"]
            };
            
            function getStationCode(locationCode) {
                if (locationCode === "BANH") return "BANH";
                if (locationCode === "STR4B") return "STR";
                return locationCode.substring(0, 3);
            }
            
            function areStationsAdjacent(station1, station2) {
                const code1 = getStationCode(station1);
                const code2 = getStationCode(station2);
                if (code1 === code2) return true;
                if (adjacencyMap[code1] && adjacencyMap[code1].includes(code2)) return true;
                if (adjacencyMap[code2] && adjacencyMap[code2].includes(code1)) return true;
                return false;
            }
            
            function parseTime(timeStr) {
                const [hours, minutes, seconds] = timeStr.split(':').map(Number);
                return hours * 3600 + minutes * 60 + seconds;
            }
            
            // Create a map of run numbers to their line indices
            const runLineIndices = {};
            lines.forEach((line, index) => {
                const parts = line.split(',');
                if (parts.length >= 7) {
                    const runNumber = parts[1].trim();
                    if (!runLineIndices[runNumber]) {
                        runLineIndices[runNumber] = [];
                    }
                    runLineIndices[runNumber].push(index);
                }
            });
            
            const allRuns = Object.keys(runLineIndices);
            
            for (const fromRun of allRuns) {
                const fromRunIndices = runLineIndices[fromRun];
                if (fromRunIndices.length === 0) continue;
                
                const lastLineIndex = Math.max(...fromRunIndices);
                const lastLine = lines[lastLineIndex];
                const lastLineParts = lastLine.split(',');
                
                const lastLocationCode = lastLineParts[4].trim();
                const lastDepartureTime = lastLineParts[6].trim();
                const lastDepartureSeconds = parseTime(lastDepartureTime);
                
                if (lastLocationCode.startsWith('J')) continue;
                
                for (let i = lastLineIndex + 1; i <= lastLineIndex + 3 && i < lines.length; i++) {
                    const nextLine = lines[i];
                    const nextLineParts = nextLine.split(',');
                    
                    if (nextLineParts.length < 7) continue;
                    
                    const nextRun = nextLineParts[1].trim();
                    if (nextRun === fromRun) continue;
                    
                    if (Math.min(...runLineIndices[nextRun]) !== i) continue;
                    
                    const nextLocationCode = nextLineParts[4].trim();
                    const nextArrivalTime = nextLineParts[5].trim();
                    const nextArrivalSeconds = parseTime(nextArrivalTime);
                    
                    if (nextLocationCode.startsWith('J')) continue;
                    
                    const timeDiffMinutes = (nextArrivalSeconds - lastDepartureSeconds) / 60;
                    
                    if (areStationsAdjacent(lastLocationCode, nextLocationCode) && 
                        timeDiffMinutes >= 0.5 && 
                        timeDiffMinutes <= 5) {
                        
                        transitions[fromRun] = { 
                            nextRun, 
                            location: nextLocationCode,
                            fromLocation: lastLocationCode
                        };
                        break;
                    }
                }
            }
            
            return transitions;
        }
        
        // Initialize particles and add event handlers
        createParticles();
        
        // Load timetable on page load (public file)
        fetchAndProcessTimetable()
            .then(() => {
                console.log('Timetable loaded on page load');
            })
            .catch(error => {
                console.error('Failed to load timetable on page load:', error);
                // Show error in main container if it's visible
                if (mainContainer && mainContainer.style.display === 'flex') {
                    document.getElementById('statusMain').textContent = 'Error loading timetable';
                    document.getElementById('statusDetails').textContent = error.message;
                }
            });
        
        // Initialize auth elements and load Firebase
        initializeAuthElements();

        loadFirebase({
            onSignedIn: initializeApp,
            onSignedOut: function() {
                // Any page-specific sign out handling
            }
        });
    </script>
</body>
</html>